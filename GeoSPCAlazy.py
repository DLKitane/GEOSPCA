"""
Created on Wed Mar  3 17:37:16 2021

@author: Driss lahlou Kitane
"""
import gurobipy as gp
from gurobipy import GRB
from sklearn.decomposition import PCA
import numpy as np
import pandas as pd

##############    PARAMETERS and DATA    ##################
nc = 8 # nc is the desired number principal components
k = 16 # k is the desired number of nonzero variables 
       # in the sparse principal components
epsilon = 0.39 # epsilon corresponds to \eta in the GeoSPCA paper
maxiter = 1000 # The maximum number of iterations desired. 
               # This will be used as stopping criterion. 
               # If the number of cuts added reaches maxiter, 
               # the algorithm stops even if an optimal solution of the BLO is not found.
data = 'path' #Enter data path here. A csv format is assumed here. 
              #Features are considered on the columns of the data.


##############    COPYING DATA and INITIALIZING VARIABLES    ##############

df = pd.read_csv(data, header = None)
n, p = df.shape
n = n - 1 # The number of data points n - 1
p = p - 1 # The number of features is p - 1
A = np.zeros((n,p)) # A is an array where the data will be saved
for i in range(n): # Copying the data to an array
    for j in range(p):
        A[i,j] = df.iloc[i + 1,j + 1]


dA = np.zeros(p) #dA is a vector of the norms of the columns of A
for i in range(p):
    dA[i] = np.linalg.norm(A[:,i])**2
    
iteration = 0 # Counting the number of iterations (cuts added)

Bindices = [] # Indices of the nonzero variables of the best solution. 
              #It is updated eventually at each iteration
Bvalue = 0 # Best objective value recorded for formulation (2)

##############    A BUNCH OF USEFUL BASIC FUNCTIONS    ##############

def subA(sup,M): # A function returning a submatrix of M formed by the columns 
                 #of M if indices sup
    index = []
    for i in range(sup.shape[0]):
        if sup[i] > 0.5:
            index.append(i)
    return M[:,index]

def disP(subA,ncA): # A function returning the squared norm of the 
# approximation of the matrix subA generated by PCA with ncA PCs. This squared 
# norm is named objval. This function returns also the squared norm of the 
# difference between subA and its approximation. 
# This squared norm is noted norm.
    pca = PCA(n_components=ncA)
    diff = subA - pca.inverse_transform(pca.fit_transform(subA, y=None))
    objval = np.linalg.norm(pca.singular_values_)**2
    norm = np.zeros(subA.shape[1])
    for i in range(subA.shape[1]):
        if np.linalg.norm(subA[:,i]) > 0:    
            norm[i] = np.linalg.norm(diff[:,i])**2
    return norm, objval

##############    INITIATING THE BINARY LINEAR PROBLEM    ##############
m = gp.Model()
s = m.addVars(range(p), vtype=GRB.BINARY, name="s")
m.setObjective( sum(dA[i] * s[i] for i in range(p)) , GRB.MAXIMIZE)
m.addConstr(s.sum('*') <= k)

##############    CUT GENERATION     ##############
def addCut(m, where):
    if where == GRB.Callback.MIPSOL:
        global iteration
        global Bindices
        global Bvalue

        if iteration < maxiter:
            sln = m.cbGetSolution(s)
            sn = np.zeros(p)
            indices = []
            for i in range(p):
                sn[i] = sln[i]
                if sn[i] > 0.5:
                    indices.append(i)
            sn = sn.astype(int)
            excess, objval = disP(A[:,indices],min([nc,sum(sn)]))
            if Bvalue <= objval:
                Bvalue = objval
                Bindices = []
                for i in range(p):
                    if sn[i] > 0.5:
                        Bindices.append(i) 
            violation = False 
            if sum(excess) > epsilon:
                violation = True
            if violation:
                m.cbLazy(gp.quicksum(s[i] for i in indices) <= sum(sn) - 1)
            iteration = iteration + 1

##############    PROBLEM SOLVING     ##############

m.Params.lazyConstraints = 1
m.optimize(addCut)


##############    BEST SOLUTION FOUND    ##############

print("Best solution found")
print('Value = ' + str(Bvalue))
print("Indices are:")
print(Bindices)
Ad3 = A[:,Bindices]
print('\eta(s) = ' + str(sum(disP(Ad3,nc)[0])))
print('number of iterations = ' +  str(iteration))

##############   RETRIEVING THE SOLUTION OF THE BLO (OPTIONAL)  ##############

#v = m.getVars()
#sn = np.zeros(p)
#indices = []
#for i in range(p):
#    sn[i] = v[i].x
#    if sn[i] > 0.5:
#        indices.append(i)
#Ad = A[:,indices]

#pca = PCA(n_components=nc)
#pca.fit(Ad)

#"BLO Solution"
#print("Objective function value = " + str(np.linalg.norm(pca.singular_values_)**2))
#print("Indices are:")
#print(indices)
#print('\eta(s) = ' + str(sum(disP(Ad,nc)[0])))
